# ICQ26a MVP Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a cross-platform Matrix chat client with ICQ98a/Windows 95 aesthetic using Tauri.

**Architecture:** Tauri 2.x app with a Rust backend wrapping `matrix-sdk` for all Matrix protocol operations, communicating via Tauri commands and events to a Svelte frontend styled with `98.css`. The Rust backend owns the Matrix client lifecycle (auth, sync, send/receive), and emits events to the frontend for real-time updates.

**Tech Stack:** Tauri 2.x, Rust, matrix-sdk 0.16, Svelte, TypeScript, 98.css, Vite

---

## Phase 1: Project Scaffolding

### Task 1: Initialize Tauri + Svelte project

**Files:**
- Create: entire project scaffold via `create tauri-app`
- Modify: `package.json` (add 98.css)
- Modify: `src-tauri/Cargo.toml` (add matrix-sdk)

**Step 1: Scaffold the project**

Run from the repo root (which is already `/Users/fsmith/src/github.com/fredsmith/icq26a/`):

```bash
npm create tauri-app@latest . -- --template svelte-ts --manager npm
```

If the tool asks about overwriting, accept — the repo only has a `ref/` folder and `docs/` folder.

**Step 2: Install 98.css**

```bash
npm install 98.css
```

**Step 3: Add matrix-sdk to Cargo.toml**

Edit `src-tauri/Cargo.toml` dependencies:

```toml
[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-shell = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
matrix-sdk = { version = "0.16", features = ["sqlite"] }
tokio = { version = "1", features = ["full"] }
dirs = "6"
```

**Step 4: Import 98.css in the frontend**

Edit `src/main.ts` to add at the top:

```typescript
import '98.css'
```

**Step 5: Verify dev loop works**

```bash
npm run tauri dev
```

Expected: A Tauri window opens with the default Svelte template, now styled with 98.css base styles (grey background, system font).

**Step 6: Commit**

```bash
git add -A
git commit -m "chore: scaffold Tauri + Svelte + 98.css project with matrix-sdk dependency"
```

---

### Task 2: Set up project structure and shared types

**Files:**
- Create: `src/lib/types.ts`
- Create: `src/lib/matrix.ts`
- Create: `src/lib/stores.ts`
- Create: `src-tauri/src/matrix_client.rs`
- Create: `src-tauri/src/commands.rs`
- Modify: `src-tauri/src/main.rs`
- Modify: `src-tauri/src/lib.rs`

**Step 1: Create TypeScript types**

Create `src/lib/types.ts`:

```typescript
export interface Buddy {
  user_id: string
  display_name: string
  avatar_url: string | null
  presence: PresenceStatus
}

export type PresenceStatus =
  | 'online'
  | 'away'
  | 'na'
  | 'occupied'
  | 'dnd'
  | 'free_for_chat'
  | 'invisible'
  | 'offline'

export interface Room {
  room_id: string
  name: string
  is_direct: boolean
  last_message: string | null
  unread_count: number
}

export interface Message {
  event_id: string
  sender: string
  sender_name: string
  body: string
  timestamp: number
  msg_type: 'text' | 'image' | 'file' | 'audio' | 'video'
}

export interface LoginCredentials {
  homeserver: string
  username: string
  password: string
}

export interface AppPreferences {
  homeserver: string
  notification_sounds: boolean
}
```

**Step 2: Create Tauri command wrappers**

Create `src/lib/matrix.ts`:

```typescript
import { invoke } from '@tauri-apps/api/core'
import type { Buddy, Room, Message, LoginCredentials } from './types'

export async function matrixLogin(credentials: LoginCredentials): Promise<string> {
  return invoke('matrix_login', { credentials })
}

export async function matrixLogout(): Promise<void> {
  return invoke('matrix_logout')
}

export async function getBuddyList(): Promise<Buddy[]> {
  return invoke('get_buddy_list')
}

export async function getRooms(): Promise<Room[]> {
  return invoke('get_rooms')
}

export async function getRoomMessages(roomId: string, limit: number = 50): Promise<Message[]> {
  return invoke('get_room_messages', { roomId, limit })
}

export async function sendMessage(roomId: string, body: string): Promise<void> {
  return invoke('send_message', { roomId, body })
}

export async function setPresence(status: string): Promise<void> {
  return invoke('set_presence', { status })
}
```

**Step 3: Create Svelte stores**

Create `src/lib/stores.ts`:

```typescript
import { writable } from 'svelte/store'
import type { Buddy, Room, PresenceStatus, AppPreferences } from './types'

export const isLoggedIn = writable(false)
export const currentUserId = writable<string | null>(null)
export const buddyList = writable<Buddy[]>([])
export const rooms = writable<Room[]>([])
export const currentStatus = writable<PresenceStatus>('online')
export const activeRoomId = writable<string | null>(null)
export const preferences = writable<AppPreferences>({
  homeserver: 'https://matrix.org',
  notification_sounds: true,
})
```

**Step 4: Create Rust matrix client wrapper**

Create `src-tauri/src/matrix_client.rs`:

```rust
use matrix_sdk::{
    Client, ServerName,
    ruma::OwnedRoomId,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Buddy {
    pub user_id: String,
    pub display_name: String,
    pub avatar_url: Option<String>,
    pub presence: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Room {
    pub room_id: String,
    pub name: String,
    pub is_direct: bool,
    pub last_message: Option<String>,
    pub unread_count: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    pub event_id: String,
    pub sender: String,
    pub sender_name: String,
    pub body: String,
    pub timestamp: u64,
    pub msg_type: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoginCredentials {
    pub homeserver: String,
    pub username: String,
    pub password: String,
}

pub struct MatrixState {
    pub client: Arc<Mutex<Option<Client>>>,
}

impl MatrixState {
    pub fn new() -> Self {
        Self {
            client: Arc::new(Mutex::new(None)),
        }
    }
}
```

**Step 5: Create Rust commands module**

Create `src-tauri/src/commands.rs`:

```rust
use crate::matrix_client::{Buddy, LoginCredentials, MatrixState, Message, Room};
use matrix_sdk::{Client, ServerName};
use tauri::State;

#[tauri::command]
pub async fn matrix_login(
    credentials: LoginCredentials,
    state: State<'_, MatrixState>,
) -> Result<String, String> {
    let server_name = ServerName::parse(&credentials.homeserver.replace("https://", ""))
        .map_err(|e| format!("Invalid homeserver: {}", e))?;

    let client = Client::builder()
        .server_name(&server_name)
        .build()
        .await
        .map_err(|e| format!("Failed to build client: {}", e))?;

    let response = client
        .matrix_auth()
        .login_username(&credentials.username, &credentials.password)
        .send()
        .await
        .map_err(|e| format!("Login failed: {}", e))?;

    let user_id = response.user_id.to_string();

    let mut client_lock = state.client.lock().await;
    *client_lock = Some(client);

    Ok(user_id)
}

#[tauri::command]
pub async fn matrix_logout(state: State<'_, MatrixState>) -> Result<(), String> {
    let mut client_lock = state.client.lock().await;
    *client_lock = None;
    Ok(())
}

#[tauri::command]
pub async fn get_buddy_list(state: State<'_, MatrixState>) -> Result<Vec<Buddy>, String> {
    let client_lock = state.client.lock().await;
    let client = client_lock.as_ref().ok_or("Not logged in")?;

    // Initial sync to get room state
    client.sync_once(Default::default()).await.map_err(|e| format!("Sync failed: {}", e))?;

    let mut buddies = Vec::new();
    for room in client.joined_rooms() {
        if room.is_direct().await.unwrap_or(false) {
            let members = room.members(matrix_sdk::RoomMemberships::ACTIVE)
                .await
                .unwrap_or_default();
            for member in members {
                let user_id = member.user_id().to_string();
                if user_id != client.user_id().map(|u| u.to_string()).unwrap_or_default() {
                    buddies.push(Buddy {
                        user_id: user_id.clone(),
                        display_name: member.display_name().unwrap_or(&user_id).to_string(),
                        avatar_url: member.avatar_url().map(|u| u.to_string()),
                        presence: "offline".to_string(),
                    });
                }
            }
        }
    }
    Ok(buddies)
}

#[tauri::command]
pub async fn get_rooms(state: State<'_, MatrixState>) -> Result<Vec<Room>, String> {
    let client_lock = state.client.lock().await;
    let client = client_lock.as_ref().ok_or("Not logged in")?;

    let mut rooms = Vec::new();
    for room in client.joined_rooms() {
        rooms.push(Room {
            room_id: room.room_id().to_string(),
            name: room.display_name().await
                .map(|n| n.to_string())
                .unwrap_or_else(|_| "Unknown".to_string()),
            is_direct: room.is_direct().await.unwrap_or(false),
            last_message: None,
            unread_count: 0,
        });
    }
    Ok(rooms)
}

#[tauri::command]
pub async fn get_room_messages(
    room_id: String,
    limit: u64,
    state: State<'_, MatrixState>,
) -> Result<Vec<Message>, String> {
    // Stub — will be implemented with timeline API
    Ok(Vec::new())
}

#[tauri::command]
pub async fn send_message(
    room_id: String,
    body: String,
    state: State<'_, MatrixState>,
) -> Result<(), String> {
    let client_lock = state.client.lock().await;
    let client = client_lock.as_ref().ok_or("Not logged in")?;

    let room_id = matrix_sdk::ruma::OwnedRoomId::try_from(room_id.as_str())
        .map_err(|e| format!("Invalid room ID: {}", e))?;

    let room = client.get_room(&room_id).ok_or("Room not found")?;

    let content = matrix_sdk::ruma::events::room::message::RoomMessageEventContent::text_plain(&body);
    room.send(content).await.map_err(|e| format!("Send failed: {}", e))?;

    Ok(())
}

#[tauri::command]
pub async fn set_presence(status: String, state: State<'_, MatrixState>) -> Result<(), String> {
    // Stub — will map ICQ statuses to Matrix presence
    Ok(())
}
```

**Step 6: Wire up main.rs**

Edit `src-tauri/src/main.rs`:

```rust
// Prevents additional console window on Windows in release
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

mod commands;
mod matrix_client;

use matrix_client::MatrixState;

fn main() {
    tauri::Builder::default()
        .plugin(tauri_plugin_shell::init())
        .manage(MatrixState::new())
        .invoke_handler(tauri::generate_handler![
            commands::matrix_login,
            commands::matrix_logout,
            commands::get_buddy_list,
            commands::get_rooms,
            commands::get_room_messages,
            commands::send_message,
            commands::set_presence,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

Update `src-tauri/src/lib.rs` to re-export modules:

```rust
mod commands;
mod matrix_client;

use matrix_client::MatrixState;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_shell::init())
        .manage(MatrixState::new())
        .invoke_handler(tauri::generate_handler![
            commands::matrix_login,
            commands::matrix_logout,
            commands::get_buddy_list,
            commands::get_rooms,
            commands::get_room_messages,
            commands::send_message,
            commands::set_presence,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

**Step 7: Verify it compiles**

```bash
cd src-tauri && cargo check
```

Expected: Successful compilation (warnings OK for unused functions).

**Step 8: Commit**

```bash
git add -A
git commit -m "feat: add project structure — Rust Matrix client, Tauri commands, Svelte types and stores"
```

---

## Phase 2: Login Window

### Task 3: Build the login UI

**Files:**
- Create: `src/components/Login.svelte`
- Modify: `src/App.svelte`
- Modify: `src/app.css`

**Step 1: Create Login component**

Create `src/components/Login.svelte`:

```svelte
<script lang="ts">
  import { matrixLogin } from '../lib/matrix'
  import { isLoggedIn, currentUserId, preferences } from '../lib/stores'
  import type { LoginCredentials } from '../lib/types'

  let username = ''
  let password = ''
  let homeserver = ''
  let error = ''
  let loading = false

  preferences.subscribe(p => {
    if (!homeserver) homeserver = p.homeserver
  })

  async function handleLogin() {
    error = ''
    loading = true
    try {
      const credentials: LoginCredentials = {
        homeserver,
        username,
        password,
      }
      const userId = await matrixLogin(credentials)
      currentUserId.set(userId)
      isLoggedIn.set(true)
    } catch (e) {
      error = String(e)
    } finally {
      loading = false
    }
  }
</script>

<div class="window login-window">
  <div class="title-bar">
    <div class="title-bar-text">ICQ26a Login</div>
    <div class="title-bar-controls">
      <button aria-label="Close"></button>
    </div>
  </div>
  <div class="window-body">
    <div class="login-logo">
      <p style="font-size: 24px; font-weight: bold; text-align: center; margin: 8px 0;">ICQ26a</p>
    </div>

    <form on:submit|preventDefault={handleLogin}>
      <div class="field-row-stacked" style="width: 200px;">
        <label for="homeserver">Homeserver:</label>
        <input id="homeserver" type="text" bind:value={homeserver} placeholder="https://matrix.org" />
      </div>
      <div class="field-row-stacked" style="width: 200px;">
        <label for="username">Username:</label>
        <input id="username" type="text" bind:value={username} placeholder="your_username" />
      </div>
      <div class="field-row-stacked" style="width: 200px;">
        <label for="password">Password:</label>
        <input id="password" type="password" bind:value={password} />
      </div>

      {#if error}
        <p class="error-text">{error}</p>
      {/if}

      <div class="field-row" style="justify-content: flex-end; margin-top: 8px;">
        <button type="submit" disabled={loading}>
          {loading ? 'Connecting...' : 'Login'}
        </button>
      </div>
    </form>
  </div>
  <div class="status-bar">
    <p class="status-bar-field">{loading ? 'Connecting...' : 'Ready'}</p>
  </div>
</div>

<style>
  .login-window {
    width: 280px;
    margin: 80px auto;
  }
  .error-text {
    color: red;
    font-size: 11px;
    margin: 4px 0;
  }
</style>
```

**Step 2: Create base app styles**

Replace `src/app.css`:

```css
:root {
  font-family: 'MS Sans Serif', 'Microsoft Sans Serif', Arial, sans-serif;
  font-size: 12px;
}

body {
  margin: 0;
  padding: 0;
  background: #c0c0c0;
  min-height: 100vh;
}

/* Utility: sunken panel (inset border) */
.sunken-panel {
  box-sizing: border-box;
  border: 2px groove transparent;
  border-image: url('data:image/svg+xml;charset=utf-8,...') 2;
  overflow-y: auto;
  background: #fff;
}
```

**Step 3: Wire up App.svelte**

Replace `src/App.svelte`:

```svelte
<script lang="ts">
  import { isLoggedIn } from './lib/stores'
  import Login from './components/Login.svelte'

  // Placeholder — BuddyList will be added next
</script>

<main>
  {#if $isLoggedIn}
    <p>Logged in! (Buddy list coming next)</p>
  {:else}
    <Login />
  {/if}
</main>
```

**Step 4: Run and verify**

```bash
npm run tauri dev
```

Expected: A Win95-styled login window appears centered on a grey background, with Homeserver, Username, and Password fields and a Login button.

**Step 5: Commit**

```bash
git add -A
git commit -m "feat: add Login window with Win95 styling and Matrix auth"
```

---

## Phase 3: Buddy List

### Task 4: Build the buddy list UI with real Matrix data

**Files:**
- Create: `src/components/BuddyList.svelte`
- Create: `src/components/StatusPicker.svelte`
- Modify: `src/App.svelte`

**Step 1: Create StatusPicker component**

Create `src/components/StatusPicker.svelte`:

```svelte
<script lang="ts">
  import { currentStatus } from '../lib/stores'
  import { setPresence } from '../lib/matrix'
  import type { PresenceStatus } from '../lib/types'

  let menuOpen = false

  const statuses: { value: PresenceStatus; label: string; color: string }[] = [
    { value: 'online', label: 'Online', color: '#00cc00' },
    { value: 'free_for_chat', label: 'Free For Chat', color: '#00cc00' },
    { value: 'away', label: 'Away', color: '#cccc00' },
    { value: 'na', label: 'N/A (Extended Away)', color: '#cccc00' },
    { value: 'occupied', label: 'Occupied (Urgent Msgs)', color: '#cc0000' },
    { value: 'dnd', label: 'DND (Do not Disturb)', color: '#cc0000' },
    { value: 'invisible', label: 'Privacy (Invisible)', color: '#999999' },
    { value: 'offline', label: 'Offline/Disconnect', color: '#999999' },
  ]

  async function selectStatus(status: PresenceStatus) {
    currentStatus.set(status)
    menuOpen = false
    await setPresence(status)
  }

  function handleClickOutside(event: MouseEvent) {
    menuOpen = false
  }
</script>

<svelte:window on:click={handleClickOutside} />

<div class="status-picker">
  <button class="status-button" on:click|stopPropagation={() => (menuOpen = !menuOpen)}>
    <span class="status-dot" style="background: {statuses.find(s => s.value === $currentStatus)?.color}"></span>
    {statuses.find(s => s.value === $currentStatus)?.label}
  </button>
  {#if menuOpen}
    <div class="status-menu">
      {#each statuses as status}
        <button
          class="status-menu-item"
          class:active={$currentStatus === status.value}
          on:click|stopPropagation={() => selectStatus(status.value)}
        >
          <span class="status-dot" style="background: {status.color}"></span>
          {status.label}
        </button>
      {/each}
    </div>
  {/if}
</div>

<style>
  .status-picker {
    position: relative;
  }
  .status-button {
    width: 100%;
    text-align: left;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .status-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
  }
  .status-menu {
    position: absolute;
    bottom: 100%;
    left: 0;
    right: 0;
    background: #c0c0c0;
    border: 2px outset #c0c0c0;
    z-index: 100;
  }
  .status-menu-item {
    display: flex;
    align-items: center;
    gap: 6px;
    width: 100%;
    border: none;
    background: transparent;
    padding: 3px 8px;
    text-align: left;
    cursor: pointer;
    font-size: 11px;
  }
  .status-menu-item:hover {
    background: #000080;
    color: white;
  }
  .status-menu-item.active {
    font-weight: bold;
  }
</style>
```

**Step 2: Create BuddyList component**

Create `src/components/BuddyList.svelte`:

```svelte
<script lang="ts">
  import { onMount } from 'svelte'
  import { buddyList, rooms, activeRoomId } from '../lib/stores'
  import { getBuddyList, getRooms } from '../lib/matrix'
  import { listen } from '@tauri-apps/api/event'
  import type { Buddy, Room } from '../lib/types'
  import StatusPicker from './StatusPicker.svelte'

  let activeTab: 'all' | 'users' = 'all'
  let searchQuery = ''

  $: onlineBuddies = $buddyList.filter(b => b.presence !== 'offline')
  $: offlineBuddies = $buddyList.filter(b => b.presence === 'offline')
  $: filteredRooms = $rooms.filter(r => !r.is_direct)

  onMount(async () => {
    try {
      const fetchedBuddies = await getBuddyList()
      buddyList.set(fetchedBuddies)
      const fetchedRooms = await getRooms()
      rooms.set(fetchedRooms)
    } catch (e) {
      console.error('Failed to load buddy list:', e)
    }
  })

  function openChat(roomId: string) {
    activeRoomId.set(roomId)
  }

  function findRoomForBuddy(buddy: Buddy): string | null {
    const room = $rooms.find(r => r.is_direct && r.name === buddy.display_name)
    return room?.room_id ?? null
  }
</script>

<div class="window buddy-list-window">
  <div class="title-bar">
    <div class="title-bar-text">ICQ26a</div>
    <div class="title-bar-controls">
      <button aria-label="Minimize"></button>
      <button aria-label="Close"></button>
    </div>
  </div>
  <div class="window-body">
    <!-- Tab bar -->
    <menu role="tablist">
      <button
        aria-selected={activeTab === 'all'}
        on:click={() => (activeTab = 'all')}
      >All</button>
      <button
        aria-selected={activeTab === 'users'}
        on:click={() => (activeTab = 'users')}
      >Users</button>
    </menu>

    <!-- Buddy/room list -->
    <div class="buddy-scroll" role="tabpanel">
      {#if activeTab === 'all'}
        {#if onlineBuddies.length > 0}
          <div class="group-header">Online</div>
          {#each onlineBuddies as buddy}
            <button class="buddy-row" on:click={() => {
              const rid = findRoomForBuddy(buddy)
              if (rid) openChat(rid)
            }}>
              <span class="status-dot online"></span>
              {buddy.display_name}
            </button>
          {/each}
        {/if}
        {#if offlineBuddies.length > 0}
          <div class="group-header">Offline</div>
          {#each offlineBuddies as buddy}
            <button class="buddy-row offline" on:click={() => {
              const rid = findRoomForBuddy(buddy)
              if (rid) openChat(rid)
            }}>
              <span class="status-dot"></span>
              {buddy.display_name}
            </button>
          {/each}
        {/if}
        {#if $buddyList.length === 0}
          <p class="empty-text">No contacts yet</p>
        {/if}
      {:else}
        <!-- Rooms tab -->
        {#each filteredRooms as room}
          <button class="buddy-row" on:click={() => openChat(room.room_id)}>
            {room.name}
          </button>
        {/each}
        {#if filteredRooms.length === 0}
          <p class="empty-text">No rooms</p>
        {/if}
      {/if}
    </div>
  </div>

  <!-- Bottom toolbar -->
  <div class="buddy-toolbar">
    <StatusPicker />
  </div>
</div>

<style>
  .buddy-list-window {
    width: 220px;
    height: 500px;
    display: flex;
    flex-direction: column;
  }
  .buddy-list-window .window-body {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    padding: 0;
  }
  menu[role="tablist"] {
    margin: 0;
    padding: 2px 4px 0;
  }
  .buddy-scroll {
    flex: 1;
    overflow-y: auto;
    background: white;
    border: 2px inset #c0c0c0;
    margin: 0 4px 4px;
  }
  .group-header {
    font-weight: bold;
    font-size: 11px;
    padding: 4px 8px 2px;
    color: #444;
  }
  .buddy-row {
    display: flex;
    align-items: center;
    gap: 6px;
    width: 100%;
    border: none;
    background: transparent;
    padding: 2px 12px;
    text-align: left;
    cursor: pointer;
    font-size: 11px;
  }
  .buddy-row:hover {
    background: #000080;
    color: white;
  }
  .buddy-row.offline {
    color: #888;
  }
  .status-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #999;
  }
  .status-dot.online {
    background: #00cc00;
  }
  .empty-text {
    text-align: center;
    color: #888;
    padding: 20px;
    font-size: 11px;
  }
  .buddy-toolbar {
    padding: 4px;
    border-top: 1px solid #808080;
  }
</style>
```

**Step 3: Update App.svelte**

Replace `src/App.svelte`:

```svelte
<script lang="ts">
  import { isLoggedIn, activeRoomId } from './lib/stores'
  import Login from './components/Login.svelte'
  import BuddyList from './components/BuddyList.svelte'
</script>

<main>
  {#if $isLoggedIn}
    <div class="app-layout">
      <BuddyList />
    </div>
  {:else}
    <Login />
  {/if}
</main>

<style>
  .app-layout {
    display: flex;
    padding: 8px;
    gap: 8px;
    height: 100vh;
    box-sizing: border-box;
  }
</style>
```

**Step 4: Run and verify**

```bash
npm run tauri dev
```

Expected: After login, a narrow buddy list window appears with All/Users tabs, online/offline groupings, and a status picker at the bottom.

**Step 5: Commit**

```bash
git add -A
git commit -m "feat: add BuddyList and StatusPicker with Matrix contact loading"
```

---

## Phase 4: Direct Messaging

### Task 5: Build the direct message window

**Files:**
- Create: `src/components/DirectMessage.svelte`
- Modify: `src/App.svelte`
- Modify: `src-tauri/src/commands.rs` (implement `get_room_messages`)

**Step 1: Implement get_room_messages in Rust**

Update the `get_room_messages` function in `src-tauri/src/commands.rs`:

```rust
#[tauri::command]
pub async fn get_room_messages(
    room_id: String,
    limit: u64,
    state: State<'_, MatrixState>,
) -> Result<Vec<Message>, String> {
    let client_lock = state.client.lock().await;
    let client = client_lock.as_ref().ok_or("Not logged in")?;

    let room_id = matrix_sdk::ruma::OwnedRoomId::try_from(room_id.as_str())
        .map_err(|e| format!("Invalid room ID: {}", e))?;

    let room = client.get_room(&room_id).ok_or("Room not found")?;

    let options = matrix_sdk::room::MessagesOptions::backward();
    let messages_response = room
        .messages(options)
        .await
        .map_err(|e| format!("Failed to get messages: {}", e))?;

    let mut messages = Vec::new();
    for event in messages_response.chunk {
        if let Ok(timeline_event) = event.event.deserialize() {
            if let matrix_sdk::ruma::events::AnyTimelineEvent::MessageLike(
                matrix_sdk::ruma::events::AnyMessageLikeEvent::RoomMessage(msg),
            ) = timeline_event
            {
                let (body, msg_type) = match msg.as_original() {
                    Some(original) => {
                        match &original.content.msgtype {
                            matrix_sdk::ruma::events::room::message::MessageType::Text(text) => {
                                (text.body.clone(), "text".to_string())
                            }
                            _ => (String::new(), "unknown".to_string()),
                        }
                    }
                    None => (String::new(), "unknown".to_string()),
                };

                messages.push(Message {
                    event_id: msg.event_id().to_string(),
                    sender: msg.sender().to_string(),
                    sender_name: msg.sender().localpart().to_string(),
                    body,
                    timestamp: msg.origin_server_ts().as_secs().into(),
                    msg_type,
                });
            }
        }
    }
    messages.reverse();
    Ok(messages)
}
```

**Step 2: Create DirectMessage component**

Create `src/components/DirectMessage.svelte`:

```svelte
<script lang="ts">
  import { onMount, onDestroy } from 'svelte'
  import { activeRoomId, rooms } from '../lib/stores'
  import { getRoomMessages, sendMessage } from '../lib/matrix'
  import { listen } from '@tauri-apps/api/event'
  import type { Message } from '../lib/types'

  let messages: Message[] = []
  let newMessage = ''
  let loading = true
  let messagesDiv: HTMLDivElement
  let unlistenNewMsg: (() => void) | null = null

  $: roomName = $rooms.find(r => r.room_id === $activeRoomId)?.name ?? 'Unknown'

  onMount(async () => {
    if ($activeRoomId) {
      await loadMessages()
    }
    unlistenNewMsg = await listen<Message>('new_message', (event) => {
      if (event.payload.sender !== '') {
        messages = [...messages, event.payload]
        scrollToBottom()
      }
    })
  })

  onDestroy(() => {
    if (unlistenNewMsg) unlistenNewMsg()
  })

  async function loadMessages() {
    if (!$activeRoomId) return
    loading = true
    try {
      messages = await getRoomMessages($activeRoomId, 50)
    } catch (e) {
      console.error('Failed to load messages:', e)
    } finally {
      loading = false
      scrollToBottom()
    }
  }

  function scrollToBottom() {
    setTimeout(() => {
      if (messagesDiv) messagesDiv.scrollTop = messagesDiv.scrollHeight
    }, 0)
  }

  async function handleSend() {
    if (!newMessage.trim() || !$activeRoomId) return
    const body = newMessage
    newMessage = ''
    try {
      await sendMessage($activeRoomId, body)
    } catch (e) {
      console.error('Failed to send:', e)
      newMessage = body
    }
  }

  function closeChat() {
    activeRoomId.set(null)
  }
</script>

<div class="window dm-window">
  <div class="title-bar">
    <div class="title-bar-text">{roomName} - Message Session</div>
    <div class="title-bar-controls">
      <button aria-label="Close" on:click={closeChat}></button>
    </div>
  </div>
  <div class="window-body">
    <!-- Header fields -->
    <div class="dm-header">
      <div class="field-row">
        <label>To:</label>
        <span>{roomName}</span>
      </div>
    </div>

    <!-- Messages area -->
    <div class="messages-area" bind:this={messagesDiv}>
      {#if loading}
        <p class="loading-text">Loading messages...</p>
      {:else if messages.length === 0}
        <p class="empty-text">No messages yet</p>
      {:else}
        {#each messages as msg}
          <div class="message">
            <span class="message-sender">{msg.sender_name}:</span>
            <span class="message-body">{msg.body}</span>
          </div>
        {/each}
      {/if}
    </div>

    <!-- Input area -->
    <div class="dm-input">
      <label for="msg-input">Enter Message:</label>
      <textarea
        id="msg-input"
        bind:value={newMessage}
        on:keydown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend() }}}
        rows="3"
      ></textarea>
    </div>

    <!-- Buttons -->
    <div class="dm-buttons">
      <button on:click={closeChat}>Cancel</button>
      <button on:click={handleSend}>Send</button>
    </div>
  </div>
</div>

<style>
  .dm-window {
    width: 400px;
    height: 500px;
    display: flex;
    flex-direction: column;
  }
  .dm-window .window-body {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .dm-header {
    padding: 0 4px;
  }
  .dm-header .field-row label {
    font-weight: bold;
    min-width: 30px;
  }
  .messages-area {
    flex: 1;
    overflow-y: auto;
    background: white;
    border: 2px inset #c0c0c0;
    padding: 4px;
    font-size: 11px;
  }
  .message {
    margin-bottom: 2px;
  }
  .message-sender {
    font-weight: bold;
    color: #000080;
  }
  .dm-input {
    padding: 0 4px;
  }
  .dm-input label {
    font-size: 11px;
    display: block;
    margin-bottom: 2px;
  }
  .dm-input textarea {
    width: 100%;
    resize: none;
    box-sizing: border-box;
  }
  .dm-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 4px;
    padding: 4px;
  }
  .loading-text, .empty-text {
    text-align: center;
    color: #888;
    padding: 20px;
  }
</style>
```

**Step 3: Update App.svelte to show DirectMessage**

Replace `src/App.svelte`:

```svelte
<script lang="ts">
  import { isLoggedIn, activeRoomId } from './lib/stores'
  import Login from './components/Login.svelte'
  import BuddyList from './components/BuddyList.svelte'
  import DirectMessage from './components/DirectMessage.svelte'
</script>

<main>
  {#if $isLoggedIn}
    <div class="app-layout">
      <BuddyList />
      {#if $activeRoomId}
        <DirectMessage />
      {/if}
    </div>
  {:else}
    <Login />
  {/if}
</main>

<style>
  .app-layout {
    display: flex;
    padding: 8px;
    gap: 8px;
    height: 100vh;
    box-sizing: border-box;
  }
</style>
```

**Step 4: Run and verify**

```bash
npm run tauri dev
```

Expected: After login, clicking a buddy opens a DM window to the right of the buddy list. Messages load, you can type and send messages with Enter or Send button.

**Step 5: Commit**

```bash
git add -A
git commit -m "feat: add DirectMessage window with message history and send"
```

---

## Phase 5: Real-time Sync

### Task 6: Add background sync loop with event emission

**Files:**
- Modify: `src-tauri/src/commands.rs` (add `start_sync` command)
- Modify: `src-tauri/src/main.rs` (register new command)
- Modify: `src-tauri/src/lib.rs` (register new command)
- Modify: `src/components/BuddyList.svelte` (listen for sync events)
- Modify: `src/components/DirectMessage.svelte` (listen for new messages)

**Step 1: Add start_sync command**

Add to `src-tauri/src/commands.rs`:

```rust
#[tauri::command]
pub async fn start_sync(
    app: tauri::AppHandle,
    state: State<'_, MatrixState>,
) -> Result<(), String> {
    let client_lock = state.client.lock().await;
    let client = client_lock.as_ref().ok_or("Not logged in")?.clone();
    drop(client_lock);

    let app_handle = app.clone();

    tokio::spawn(async move {
        client.add_event_handler(
            move |event: matrix_sdk::ruma::events::room::message::SyncRoomMessageEvent,
                  room: matrix_sdk::Room| {
                let app = app_handle.clone();
                async move {
                    if let Some(original) = event.as_original() {
                        if let matrix_sdk::ruma::events::room::message::MessageType::Text(text) =
                            &original.content.msgtype
                        {
                            let msg = Message {
                                event_id: event.event_id().to_string(),
                                sender: event.sender().to_string(),
                                sender_name: event.sender().localpart().to_string(),
                                body: text.body.clone(),
                                timestamp: event.origin_server_ts().as_secs().into(),
                                msg_type: "text".to_string(),
                            };
                            let _ = app.emit("new_message", &msg);
                        }
                    }
                }
            },
        );

        let settings = matrix_sdk::config::SyncSettings::default();
        client.sync(settings).await;
    });

    Ok(())
}
```

**Step 2: Register the new command in both main.rs and lib.rs**

Add `commands::start_sync` to the `generate_handler!` macro in both files.

**Step 3: Trigger sync after login**

In `src/components/Login.svelte`, after successful login, add:

```typescript
import { invoke } from '@tauri-apps/api/core'

// After isLoggedIn.set(true):
await invoke('start_sync')
```

**Step 4: Verify real-time messages**

Open the app, log in, open a DM. Send a message from another Matrix client — it should appear in the DM window in real time.

**Step 5: Commit**

```bash
git add -A
git commit -m "feat: add background Matrix sync with real-time message events"
```

---

## Phase 6: Preferences Pane

### Task 7: Build the preferences window

**Files:**
- Create: `src/components/Preferences.svelte`
- Modify: `src/App.svelte`

**Step 1: Create Preferences component**

Create `src/components/Preferences.svelte`:

```svelte
<script lang="ts">
  import { preferences } from '../lib/stores'
  import type { AppPreferences } from '../lib/types'
  import { createEventDispatcher } from 'svelte'

  const dispatch = createEventDispatcher()

  let localPrefs: AppPreferences = { ...$preferences }

  function handleSave() {
    preferences.set({ ...localPrefs })
    dispatch('close')
  }

  function handleCancel() {
    dispatch('close')
  }
</script>

<div class="window prefs-window">
  <div class="title-bar">
    <div class="title-bar-text">Preferences</div>
    <div class="title-bar-controls">
      <button aria-label="Close" on:click={handleCancel}></button>
    </div>
  </div>
  <div class="window-body">
    <fieldset>
      <legend>Connection</legend>
      <div class="field-row-stacked" style="width: 280px;">
        <label for="pref-homeserver">Homeserver URL:</label>
        <input id="pref-homeserver" type="text" bind:value={localPrefs.homeserver} />
      </div>
    </fieldset>

    <fieldset>
      <legend>Notifications</legend>
      <div class="field-row">
        <input id="pref-sounds" type="checkbox" bind:checked={localPrefs.notification_sounds} />
        <label for="pref-sounds">Enable notification sounds</label>
      </div>
    </fieldset>

    <div class="prefs-buttons">
      <button on:click={handleSave}>OK</button>
      <button on:click={handleCancel}>Cancel</button>
    </div>
  </div>
</div>

<style>
  .prefs-window {
    width: 350px;
    margin: 40px auto;
  }
  fieldset {
    margin-bottom: 8px;
  }
  .prefs-buttons {
    display: flex;
    justify-content: flex-end;
    gap: 4px;
    margin-top: 8px;
  }
</style>
```

**Step 2: Add preferences toggle to App.svelte**

Update `src/App.svelte` to include a way to open preferences (e.g., from buddy list toolbar or menu). Add the Preferences component with a `showPreferences` flag.

**Step 3: Run and verify**

Expected: Preferences window opens with homeserver URL field (defaulting to matrix.org) and notification sound toggle.

**Step 4: Commit**

```bash
git add -A
git commit -m "feat: add Preferences pane with homeserver config and notification toggle"
```

---

## Phase 7: Multi-User Chat

### Task 8: Build the multi-user chat window

**Files:**
- Create: `src/components/ChatRoom.svelte`
- Modify: `src/App.svelte`

**Step 1: Create ChatRoom component**

Create `src/components/ChatRoom.svelte` — similar to DirectMessage but with:
- A participant list sidebar
- Sender names displayed more prominently
- Menu bar (File/Edit/Display)
- Timestamps on each message

The layout mirrors the split-pane style from the reference screenshot.

```svelte
<script lang="ts">
  import { onMount, onDestroy } from 'svelte'
  import { activeRoomId, rooms } from '../lib/stores'
  import { getRoomMessages, sendMessage } from '../lib/matrix'
  import { listen } from '@tauri-apps/api/event'
  import type { Message } from '../lib/types'

  let messages: Message[] = []
  let newMessage = ''
  let loading = true
  let messagesDiv: HTMLDivElement

  $: room = $rooms.find(r => r.room_id === $activeRoomId)
  $: roomName = room?.name ?? 'Chat'
  $: isGroupChat = room ? !room.is_direct : false

  onMount(async () => {
    if ($activeRoomId) {
      loading = true
      try {
        messages = await getRoomMessages($activeRoomId, 50)
      } catch (e) {
        console.error('Failed to load messages:', e)
      } finally {
        loading = false
      }
    }
  })

  async function handleSend() {
    if (!newMessage.trim() || !$activeRoomId) return
    const body = newMessage
    newMessage = ''
    try {
      await sendMessage($activeRoomId, body)
    } catch (e) {
      console.error('Failed to send:', e)
      newMessage = body
    }
  }

  function closeChat() {
    activeRoomId.set(null)
  }

  function formatTime(ts: number): string {
    const d = new Date(ts * 1000)
    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })
  }
</script>

<div class="window chat-window">
  <div class="title-bar">
    <div class="title-bar-text">ICQ Chat - {roomName}</div>
    <div class="title-bar-controls">
      <button aria-label="Close" on:click={closeChat}></button>
    </div>
  </div>

  <!-- Menu bar -->
  <div class="menu-bar">
    <button>File</button>
    <button>Edit</button>
    <button>Display</button>
  </div>

  <div class="window-body chat-body">
    <!-- Messages pane -->
    <div class="chat-messages" bind:this={messagesDiv}>
      {#if loading}
        <p class="loading-text">Loading...</p>
      {:else}
        {#each messages as msg}
          <div class="chat-message">
            <div class="chat-message-header">
              <span class="chat-sender">{msg.sender_name}</span>
              <span class="chat-time">{formatTime(msg.timestamp)}</span>
            </div>
            <div class="chat-message-body">{msg.body}</div>
          </div>
        {/each}
      {/if}
    </div>

    <!-- Input area -->
    <div class="chat-input">
      <textarea
        bind:value={newMessage}
        on:keydown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend() }}}
        rows="3"
        placeholder="Type a message..."
      ></textarea>
      <button on:click={handleSend}>Send</button>
    </div>
  </div>
</div>

<style>
  .chat-window {
    width: 500px;
    height: 500px;
    display: flex;
    flex-direction: column;
  }
  .menu-bar {
    display: flex;
    gap: 0;
    padding: 2px 4px;
    background: #c0c0c0;
    border-bottom: 1px solid #808080;
  }
  .menu-bar button {
    border: none;
    background: transparent;
    padding: 2px 8px;
    font-size: 11px;
    cursor: pointer;
  }
  .menu-bar button:hover {
    background: #000080;
    color: white;
  }
  .chat-body {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  .chat-messages {
    flex: 1;
    overflow-y: auto;
    background: #000;
    color: #fff;
    padding: 4px;
    font-size: 11px;
    font-family: 'Courier New', monospace;
  }
  .chat-message {
    margin-bottom: 4px;
  }
  .chat-message-header {
    display: flex;
    justify-content: space-between;
  }
  .chat-sender {
    font-weight: bold;
    color: #00cccc;
  }
  .chat-time {
    color: #888;
    font-size: 10px;
  }
  .chat-message-body {
    padding-left: 8px;
  }
  .chat-input {
    display: flex;
    gap: 4px;
    padding: 4px;
  }
  .chat-input textarea {
    flex: 1;
    resize: none;
  }
  .loading-text {
    text-align: center;
    color: #888;
    padding: 20px;
  }
</style>
```

**Step 2: Update App.svelte to route between DM and ChatRoom**

```svelte
{#if $activeRoomId}
  {#if $rooms.find(r => r.room_id === $activeRoomId)?.is_direct}
    <DirectMessage />
  {:else}
    <ChatRoom />
  {/if}
{/if}
```

**Step 3: Run and verify**

Expected: Clicking a group room from the Users tab opens a dark-background chat window with timestamps and colored sender names. DMs still open the lighter DM window.

**Step 4: Commit**

```bash
git add -A
git commit -m "feat: add ChatRoom window for multi-user chats with dark theme and timestamps"
```

---

## Phase 8: Notifications

### Task 9: Add notification sounds and visual indicators

**Files:**
- Create: `src/lib/notifications.ts`
- Create: `public/sounds/` (directory for user-provided sound files)
- Modify: `src/components/BuddyList.svelte` (unread indicators)
- Modify: `src/App.svelte` (listen for new_message events globally)

**Step 1: Create notification handler**

Create `src/lib/notifications.ts`:

```typescript
import { get } from 'svelte/store'
import { preferences, activeRoomId } from './stores'

let messageSound: HTMLAudioElement | null = null

export function initNotifications() {
  try {
    messageSound = new Audio('/sounds/message.wav')
  } catch {
    console.warn('Notification sound not found')
  }
}

export function playMessageSound() {
  const prefs = get(preferences)
  if (prefs.notification_sounds && messageSound) {
    messageSound.currentTime = 0
    messageSound.play().catch(() => {})
  }
}
```

**Step 2: Create sounds directory**

```bash
mkdir -p public/sounds
```

Place user-provided `.wav` files here (e.g., `message.wav`, `online.wav`). The app will gracefully degrade if files are absent.

**Step 3: Wire up notifications in App.svelte**

In `App.svelte`, listen for `new_message` events globally and call `playMessageSound()` when the message is for a non-active room.

**Step 4: Add unread indicators to buddy list**

Add a small counter or bold text for buddies/rooms with unread messages.

**Step 5: Commit**

```bash
git add -A
git commit -m "feat: add notification sounds and unread message indicators"
```

---

## Phase 9: File Transfer

### Task 10: Add file upload/download support

**Files:**
- Modify: `src-tauri/src/commands.rs` (add `upload_file`, `download_file`)
- Modify: `src/components/DirectMessage.svelte` (add file attach button)
- Modify: `src/components/ChatRoom.svelte` (add file attach button)

**Step 1: Add upload_file command**

```rust
#[tauri::command]
pub async fn upload_file(
    room_id: String,
    file_path: String,
    state: State<'_, MatrixState>,
) -> Result<(), String> {
    let client_lock = state.client.lock().await;
    let client = client_lock.as_ref().ok_or("Not logged in")?;

    let room_id = matrix_sdk::ruma::OwnedRoomId::try_from(room_id.as_str())
        .map_err(|e| format!("Invalid room ID: {}", e))?;
    let room = client.get_room(&room_id).ok_or("Room not found")?;

    let data = std::fs::read(&file_path)
        .map_err(|e| format!("Failed to read file: {}", e))?;

    let filename = std::path::Path::new(&file_path)
        .file_name()
        .unwrap_or_default()
        .to_string_lossy()
        .to_string();

    let mime = mime_guess::from_path(&file_path).first_or_octet_stream();

    let response = client
        .media()
        .upload(&mime, data)
        .await
        .map_err(|e| format!("Upload failed: {}", e))?;

    // Send file message event
    let content = matrix_sdk::ruma::events::room::message::RoomMessageEventContent::new(
        matrix_sdk::ruma::events::room::message::MessageType::File(
            matrix_sdk::ruma::events::room::message::FileMessageEventContent::plain(
                filename,
                response.content_uri,
            ),
        ),
    );
    room.send(content).await.map_err(|e| format!("Send failed: {}", e))?;

    Ok(())
}
```

**Step 2: Add file picker to chat components**

Use Tauri's dialog plugin for native file picker:

```bash
cd src-tauri && cargo add tauri-plugin-dialog
```

Add an "Attach" button to both DirectMessage and ChatRoom that opens a file dialog and calls `upload_file`.

**Step 3: Render file messages**

Update message rendering to show file/image messages with download links.

**Step 4: Commit**

```bash
git add -A
git commit -m "feat: add file upload/download via Matrix media API"
```

---

## Summary

| Phase | Task | What it delivers |
|-------|------|-----------------|
| 1 | Tasks 1-2 | Scaffolded project, compiles, types defined |
| 2 | Task 3 | Login window with Matrix auth |
| 3 | Task 4 | Buddy list with online/offline groupings |
| 4 | Task 5 | Direct message send/receive |
| 5 | Task 6 | Real-time sync loop |
| 6 | Task 7 | Preferences pane (homeserver config) |
| 7 | Task 8 | Multi-user chat rooms |
| 8 | Task 9 | Notification sounds + unread indicators |
| 9 | Task 10 | File transfer |

After Task 6, you have a **functional MVP** — you can log in, see contacts, and send/receive messages in real time. Tasks 7-10 build on top.
